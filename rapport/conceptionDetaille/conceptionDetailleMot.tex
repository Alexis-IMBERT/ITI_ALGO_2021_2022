\begin{algorithme}
    
    \begin{enregistrement}{Mot}%
        \champEnregistrement{\chaine}{chaine}%
        \champEnregistrement{NaturelNonNul}{longueur}
    \end{enregistrement}

     \fonction{estUneLettre}
      {c : \caractere}%
      {\booleen}%
      {}%
      {
          \retourner{$('a' \leq$ c ET c $\leq 'z' )$ OU ('A' $\leq$ c ET c $\leq$ 'Z') OU c = '-'}
      }
\end{algorithme}

***********************************************************************************
\begin{algorithme}
      \fonction{longueur}
       {mot : Mot}%
       {\entier}%
       {}%
       {
         
        \retourner{mot.longueur}

        }
\end{algorithme}

***********************************************************************************
\begin{algorithme}
    \fonction{estUnMot}%
     {chaine : \chaine}%
     {\booleen}%
     {i: \entier, res : \booleen, c: \caractere}%
     {     

         \sialorssinon{longueur(chaine) = 0}%
        	{
        		\retourner{Faux}
        	}%
        	{
                \affecter{res}{Vrai}

		    	\pour{i}{1}{longueur(chaine)}{}%
			   {
			      \affecter{c}{chaine[i]}%
			      \sialors{non(estUneLettre(c))}%
				  {
				     \affecter{res}{faux}
				  }%
		           }%
                }%
        
           \retourner{res}
      }
  
\end{algorithme}

***********************************************************************************
\begin{algorithme}
    \fonctionAvecPreconditions{creerMot}
    {s : \chaine}%
    {Mot}%
    {estUnMot(s)}%
    {Mot : resultat}%
    {
    \affecter{resultat.chaine}{s}
    \instructon{fixerLongueurMot(resultat, longueur(s))}
    \retourner{resultat}
    }
\end{algorithme}

***********************************************************************************
\begin{algorithme}
    \fonction{sontEgaux}
     {m1,m2 : Mot}%
     {\booleen}%
     {res : \booleen \\ i : \entier \\ chaine1, chaine2 : \chaine}%
     {
     	  \affecter{res}{Vrai}
     	  \affecter{i}{0}
          \sialorssinon{longueurMot(m1)$\neq$ longueurMot(m2)}%
                  {
                   \affecter{res}{Faux}
                  }%
                  {
		   		   \affecter{chaine1}{motEnChaine(m1)}
		           \affecter{chaine2}{motEnChaine(m2)}
                   \tantque{(res = vrai) ET (i $\leq$ longueurMot(m1))}%
                    {
                     \sialors{chaine1[i] != chaine2[i]}%
                       {
                        \affecter{res}{Faux}%
                       }
                       
                       \affecter{i}{i + 1}
                       
                    }
                   }%
      
         \retourner{res}
      }
\end{algorithme}

***********************************************************************************
\begin{algorithme}
      \fonctionAvecPreconditions{supprimerLettre}
       {pos : \naturelNonNul, m : Mot}
       {Mot}
       {pos $\leq$ longueurMot(m) ET 0 $\leq$ pos}
       {nvChaine, chaine : \chaine \\ longueurMot : NaturelNonNul\\ nvMot : Mot}
       {
       \affecter{nvChaine}{motEnChaine(m)}
       \pour{i}{pos + 1}{longueurMot(m)}{}
             {
               \affecter{nvChaine[i - 1]}{chaine[i]}
             }
       \affecter{nvMot}{creerMot(nvChaine)}
       \retourner{nvMot}%    
       }
       
\end{algorithme}

***********************************************************************************
\begin{algorithme}
      \fonctionAvecPreconditions{insererLettre}%
       {pos : NaturelNonNul, c : \caractere, mot : Mot}%
       {Mot}%
       {(pos $\leq$ longueur(mot)+1)) ET (estUneLettre(c))}%
       {chaine, nouvelleChaine : \chaine, i : NaturelNonNul}
       {
            \affecter{chaine}{motEnChaine(mot)}
            \affecter{nouvelleChaine}{chaine}
            \pour{i}{pos + 1}{longueur(mot) + 1}{}%
            {
                \affecter{nouvelleChaine[i]}{chaine[i - 1]}
            }
            \affecter{nouvelleChaine[pos]}{c}

            \retourner{creerMot(nouvelleChaine)}
            
       }
\end{algorithme}

***********************************************************************************
\begin{algorithme}%
      \fonctionAvecPreconditions{remplacerLettre}
       {position : NaturelNonNul,c : \caractere, mot : Mot}%
       {Mot}%
       {(pos $\leq$ longueur(mot))) ET (estUneLettre(c))}
       {nouvelleChaine : \chaine}
       {
          \affecter{nouvelleChaine}{motEnChaine(mot)}
          \affecter{nouvelleChaine[position]}{c}      
          \retourner{creerMot(nouvelleChaine)}
       }
\end{algorithme}

***********************************************************************************
\begin{algorithme}%
      \fonctionAvecPreconditions{inverserLettre}
      {mot : Mot, pos : NaturelNonNul}%
      {Mot}%
      {pos $<$ longueur(mot)}%
      {nouvelleChaine : \chaine, temp: \caractere }%
      {
        \affecter{nouvelleChaine}{motEnChaine(mot)}
          \affecter{temp}{nouvelleChaine[pos]}%
          \affecter{nouvelleChaine[pos]}{nouvelleChaine[pos+1]}%
          \affecter{nouvelleChaine[pos+1]}{temp}%
         \retourner{creerMot(nouvelleChaine)}
      }
\end{algorithme}

***********************************************************************************
\begin{algorithme}
         \fonctionAvecPreconditions{decomposerMot}
         {pos : NaturelNonNul, mot : Mot}%
         {Mot, Mot}%
         {(pos $<$ longueur(unMot)) ET (pos $>$ 1)}%
         {i : NaturelNonNul; nvChaine1, nvChaine2 : \chaine}%
         {
           \pour{i}{1}{pos}{}%
            {
             \affecter{nvChaine1[i]}{mot[i]}%
            }
           \pour{i}{pos+1}{longueur(unMot)}{}%
            {
             \affecter{nvChaine2[i - pos]}{mot[i]}%
            }
           \retourner{creerMot(nvChaine1), creerMot(nvChaine2)}%  
          }
\end{algorithme}
