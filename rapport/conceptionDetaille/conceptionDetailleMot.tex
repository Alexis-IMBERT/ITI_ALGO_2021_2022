\begin{algorithme}
    
    \begin{enregistrement}{Mot}%
        \champEnregistrement{\chaine}{chaine}%
        \champEnregistrement{NaturelNonNul}{longueur}
    \end{enregistrement}

     \fonction{estUneLettre}
      {c : \caractere}%
      {\booleen}%
      {}%
      {
          \retourner{$('a' \leq$ c ET c $\leq 'z' )$ OU ('A' $\leq$ c ET c $\leq$ 'Z') OU c = '-'}
      }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
      \fonction{longueur}
       {mot : Mot}%
       {\entier}%
       {}%
       {
         
        \retourner{mot.longueur}

        }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
    \fonction{estUnMot}%
     {chaine : \chaine}%
     {\booleen}%
     {i: \entier, res : \booleen, c: \caractere}%
     {     

         \sialorssinon{longueur(chaine) = 0}%
        	{
        		\retourner{Faux}
        	}%
        	{
                \affecter{res}{Vrai}

		    	\pour{i}{1}{longueur(chaine)}{}%
			   {
			      \affecter{c}{chaine[i]}%
			      \sialors{non(estUneLettre(c))}%
				  {
				     \affecter{res}{faux}
				  }%
		           }%
                }%
        
           \retourner{res}
      }
  
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
    \fonctionAvecPreconditions{créerMot}
    {chaine : \chaine}%
    {Mot}%
    {estUnMot(chaine)}%
    {Mot : resultat}%
    {
    \affecter{resultat.chaine}{chaine}
    \affecter{resultat.longueur}{longueur(chaine)}
    \retourner{resultat}
    }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
    \fonction{sontEgaux}
     {mot1,mot2 : Mot}%
     {\booleen}%
     {res : \booleen, i : \entier }%
     {
          \sialorssinon{longueur(mot1)$\neq$ longueur(mot2)}%
                  {
                   \retourner{Faux}
                  }%
                  {
                   \affecter{res}{Vrai}
                   \affecter{i}{0}
                   \tantque{(res = vrai) ET (i $\leq$ longueur(mot1))}%
                    {
                     \sialors{mot1[i] != mot2[i]}%
                       {
                        \affecter{res}{Faux}%
                       }
                       
                       \affecter{i}{i + 1}
                       
                    }
                   }%
      
         \retourner{res}
      }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
      \fonctionAvecPreconditions{supprimerLettre}
       {pos : NaturelNonNul, mot : Mot}
       {Mot}
       {pos $\leq$ longueur(mot)}
       {nouvelleChaine : \chaine, longueurMot : NaturelNonNul}
       {
       \affecter{longueurMot}{longueur(mot)}
       \affecter{nouvelleChaine}{motEnChaine(mot)}
       	\pour{i}{pos + 1}{longueurMot}{}
             {
               \affecter{nouvelleChaine[i - 1]}{chaine[i]}
             }
        \retourner{creerMot(nouvelleChaine)}%    
        }
       
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
      \fonctionAvecPreconditions{insererLettre}%
       {pos : NaturelNonNul, c : \caractere, mot : Mot}%
       {Mot}%
       {(pos $\leq$ longueur(mot)+1)) ET (estUneLettre(c))}%
       {chaine, nouvelleChaine : \chaine, i : NaturelNonNul}
       {
            \affecter{chaine}{motEnChaine(mot)}
            \affecter{nouvelleChaine}{chaine}
            \pour{i}{pos + 1}{longueur(mot) + 1}{}%
            {
                \affecter{nouvelleChaine[i]}{chaine[i - 1]}
            }
            \affecter{nouvelleChaine[pos]}{c}

            \retourner{creerMot(nouvelleChaine)}
            
       }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}%
      \fonctionAvecPreconditions{RemplacerLettre}
       {position : \entier,c : \caractere, mot : Mot}%
       {Mot}%
       {(pos $\leq$ longueur(mot))) ET (estUneLettre(c))}
       {nouvelleChaine : \chaine}
       {
          \affecter{nouvelleChaine}{motEnChaine(mot)}
          \affecter{nouvelleChaine[position]}{c}      
          \retourner{creerMot(nouvelleChaine)}
       }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}%
      \fonctionAvecPreconditions{inverserDeuxLettresConsecutives}
      {position : \entier}%
      {mot : Mot}%
      {pos $<$ longueur(mot)}%
      {a: \caractere }%
      {
          \affecter{a}{mot[pos]}%
          \affecter{mot[pos]}{mot[pos+1]}%
          \affecter{mot[pos+1]}{a}%
         
      }
\end{algorithme}

/***********************************************************************************/
\begin{algorithme}
         \fonctionAvecPreconditions{décomposerMot}
         {pos : \entier,unMot : Mot}%
         {Mot, Mot}%
         {(pos $<$ longueur(unMot)) $\land$ \& (pos $>$ 1)}%
         {i : \entier, mot1,mot2: Mot}%
         {
               \pour{i}{1}{pos}{}%
                {
                 \affecter{mot1[i]}{unMot[i]}%
                }
               \pour{i}{pos+1}{longueur(unMot)}{}%
                {
                 \affecter{mot2[i]}{unMot[i]}%
                }
               \retourner{mot1}%  
               \retourner{mot2}%
          }
\end{algorithme}
